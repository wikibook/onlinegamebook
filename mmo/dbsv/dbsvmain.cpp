/*
  dbsv : generated by dbgen.py, do not edit this!!
 */
// 通信ミドルウェアのヘッダ
#include "vce2.h"
// logサーバが実装する通信プロトコルを定義するためのヘッダ
#include "dbproto.h" 
// 標準ライブラリを使うためのヘッダ
#include <iostream>
// MySQLアクセスのためのヘッダ
#include "my_global.h"
#include "mysql.h"
#include "mysqld_error.h"
// プロジェクトで作成したヘッダ
#include "dbsvmain.h"
#include "qm.h"
#include "util.h"
// dbsvではたった1個のmysqlへのセッションを共有する
MYSQL mysql;
size_t DBServer::Recv(const vce::VUint8 *p,size_t sz){
    std::cerr << "recv:" << sz << std::endl;        
    return db_proto_server::Recv(p,sz);
};
void assertPrint( MYSQL*m, std::string q ){
    std::cerr << "mysql_query fail:" << mysql_error(m) << ":" << q << std::endl;
    assert(0);    
}
void DBServer::recv_ping( vce::VUint64 timestamp )
{
    send_ping(timestamp);
}
// 新しいIDを生成して確保する
void DBServer::recv_getNewID(vce::VUint32 num)
{
    vce::VUint64 ids[MAXIDSET];
    if( num > MAXIDSET ){
        num = MAXIDSET;
    }
    std::string upd_q( "UPDATE id_generator SET id=LAST_INSERT_ID(id+1);" );
    std::string sel_q( "SELECT LAST_INSERT_ID();" );
    for(int i=0;i<num;i++){
        if( mysql_query( &mysql, upd_q.c_str())){
            assertPrint( &mysql, upd_q );
            return;
        }
        if( mysql_query( &mysql, sel_q.c_str())){
            assertPrint( &mysql, sel_q );
            return;
        }
        MYSQL_RES *result;
        if( !(result = mysql_store_result(&mysql))){
            assertPrint( &mysql, sel_q );
            return;
        }
        MYSQL_ROW row;
        if( !(row=mysql_fetch_row(result))){
            mysql_free_result(result);
            assertPrint( &mysql, "no row!");
            return;
        }
        mysql_free_result(result);
        ids[i] = atoll( row[0] );
    }
    std::cerr << "recv_getNewID: sending new " << num << " ids" << std::endl;
    send_getNewIDResult( ids, num );
}
// まずselectし、新規ならinsertし、既存ならupdateする。
void DBServer::recv_put_Player( vce::VUint32 sessionID, Player data )
{
    QueryMaker selqm( "SELECT id FROM Player WHERE ", "","" );    
    selqm.add_qword("id", data.id);
    selqm.finish();
    std::string selquery = selqm.output();
    std::cerr << "selquery: " << selquery << std::endl;
    if( mysql_query( &mysql, selquery.c_str())){
        assertPrint( &mysql, selquery );
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selquery);
        return;        
    }
    std::string query, queryBase;
    bool existing;
    if( mysql_num_rows(result) == 1 ){
        queryBase = std::string( "UPDATE" );
        existing = true;
    } else {
        queryBase = std::string( "INSERT INTO" );
        existing = false;
    }
    mysql_free_result(result);
    QueryMaker qm( queryBase.c_str(), "Player", "SET" ); 
    qm.add_qword("id", data.id);
    qm.add_string("accountName", data.accountName);
    qm.add_string("passwordHash", data.passwordHash);
    if( existing ){
        qm.append( " where " );
        qm.set_first();
        qm.add_qword( "id", data.id );
    }
    qm.finish();
    query = qm.output();
    std::cerr << "query: " << query << std::endl;
    if( mysql_query( &mysql, query.c_str())){
        if( mysql_errno(&mysql) == ER_DUP_ENTRY ){
            std::cerr << "db_proto::DUPENTRY" << std::endl;
            send_put_Player_result( sessionID, db_proto::DUPENTRY, data );
            return;
        } else {
            assertPrint( &mysql, query );
            return;
        }
    } else {
        std::cerr << "query success" << std::endl;
    }
    std::cerr << "db_proto::SUCCESS" << std::endl;    
    send_put_Player_result( sessionID, db_proto::SUCCESS, data );
}
void DBServer::recv_get_Player_by_id( vce::VUint32 sessionID, vce::VUint64 id )
{
    QueryMaker selqm( "SELECT "
                      "id"
                      ", "
                      "accountName"
                      ", "
                      "passwordHash"
                      " "
                      " FROM Player WHERE ", "",""  );
    selqm.add_qword( "id", id );
    selqm.finish();
    std::cerr << "selquery:" << selqm.output() << std::endl;
    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 3 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::Player data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. id:" << id << std::endl;
            db_proto::Player data;            
            send_get_Player_by_id_result( sessionID, db_proto::NONE, ( Player*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        strncpy( data[i].accountName, row[cnt++], 50 );
        data[i].accountName[50-1]='\0';
        strncpy( data[i].passwordHash, row[cnt++], 50 );
        data[i].passwordHash[50-1]='\0';
        actualRows = i+1;
    }
    send_get_Player_by_id_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// ranking func
void DBServer::recv_get_Player_ranking_by_id( vce::VUint32 sessionID, SortType sorttype, vce::VUint32 limit, vce::VUint32 offset )
{
    std::ostringstream ss;
    ss << "SELECT ";
    ss << "id";
    ss << ", ";
    ss << "accountName";
    ss << ", ";
    ss << "passwordHash";
    ss << " ";
    ss << " FROM Player order by id ";
    if( sorttype == SORT_BIGGERFIRST ){
        ss << "desc ";
    }
    ss << "limit " << limit << " offset " << offset << ";";
    std::cerr << "query:" << ss.str() << std::endl;
    if( mysql_query( &mysql, ss.str().c_str())){
        assertPrint( &mysql, ss.str());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, ss.str());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 3 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::Player data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. " << std::endl;
            db_proto::Player data;
            send_get_Player_ranking_by_id_result( sessionID, db_proto::NONE, ( Player*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        strncpy( data[i].accountName, row[cnt++], 50 );
        data[i].accountName[50-1]='\0';
        strncpy( data[i].passwordHash, row[cnt++], 50 );
        data[i].passwordHash[50-1]='\0';
        actualRows = i+1;
    }
    send_get_Player_ranking_by_id_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
void DBServer::recv_get_Player_by_accountName( vce::VUint32 sessionID, const char * accountName )
{
    QueryMaker selqm( "SELECT "
                      "id"
                      ", "
                      "accountName"
                      ", "
                      "passwordHash"
                      " "
                      " FROM Player WHERE ", "",""  );
    selqm.add_string( "accountName", accountName );
    selqm.finish();
    std::cerr << "selquery:" << selqm.output() << std::endl;
    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 3 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::Player data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. accountName:" << accountName << std::endl;
            db_proto::Player data;            
            send_get_Player_by_accountName_result( sessionID, db_proto::NONE, ( Player*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        strncpy( data[i].accountName, row[cnt++], 50 );
        data[i].accountName[50-1]='\0';
        strncpy( data[i].passwordHash, row[cnt++], 50 );
        data[i].passwordHash[50-1]='\0';
        actualRows = i+1;
    }
    send_get_Player_by_accountName_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// ranking func
void DBServer::recv_get_Player_ranking_by_accountName( vce::VUint32 sessionID, SortType sorttype, vce::VUint32 limit, vce::VUint32 offset )
{
    std::ostringstream ss;
    ss << "SELECT ";
    ss << "id";
    ss << ", ";
    ss << "accountName";
    ss << ", ";
    ss << "passwordHash";
    ss << " ";
    ss << " FROM Player order by accountName ";
    if( sorttype == SORT_BIGGERFIRST ){
        ss << "desc ";
    }
    ss << "limit " << limit << " offset " << offset << ";";
    std::cerr << "query:" << ss.str() << std::endl;
    if( mysql_query( &mysql, ss.str().c_str())){
        assertPrint( &mysql, ss.str());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, ss.str());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 3 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::Player data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. " << std::endl;
            db_proto::Player data;
            send_get_Player_ranking_by_accountName_result( sessionID, db_proto::NONE, ( Player*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        strncpy( data[i].accountName, row[cnt++], 50 );
        data[i].accountName[50-1]='\0';
        strncpy( data[i].passwordHash, row[cnt++], 50 );
        data[i].passwordHash[50-1]='\0';
        actualRows = i+1;
    }
    send_get_Player_ranking_by_accountName_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// まずselectし、新規ならinsertし、既存ならupdateする。
void DBServer::recv_put_PlayerCharacter( vce::VUint32 sessionID, PlayerCharacter data )
{
    QueryMaker selqm( "SELECT id FROM PlayerCharacter WHERE ", "","" );    
    selqm.add_qword("id", data.id);
    selqm.finish();
    std::string selquery = selqm.output();
    std::cerr << "selquery: " << selquery << std::endl;
    if( mysql_query( &mysql, selquery.c_str())){
        assertPrint( &mysql, selquery );
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selquery);
        return;        
    }
    std::string query, queryBase;
    bool existing;
    if( mysql_num_rows(result) == 1 ){
        queryBase = std::string( "UPDATE" );
        existing = true;
    } else {
        queryBase = std::string( "INSERT INTO" );
        existing = false;
    }
    mysql_free_result(result);
    QueryMaker qm( queryBase.c_str(), "PlayerCharacter", "SET" ); 
    qm.add_qword("id", data.id);
    qm.add_qword("playerID", data.playerID);
    qm.add_string("name", data.name);
    qm.add_word("level", data.level);
    qm.add_dword("exp", data.exp);
    qm.add_dword("hp", data.hp);
    qm.add_dword("maxhp", data.maxhp);
    qm.add_dword("floorID", data.floorID);
    qm.add_dword("x", data.x);
    qm.add_dword("y", data.y);
    qm.add_dword("equippedItemTypeID", data.equippedItemTypeID);
    if( existing ){
        qm.append( " where " );
        qm.set_first();
        qm.add_qword( "id", data.id );
    }
    qm.finish();
    query = qm.output();
    std::cerr << "query: " << query << std::endl;
    if( mysql_query( &mysql, query.c_str())){
        if( mysql_errno(&mysql) == ER_DUP_ENTRY ){
            std::cerr << "db_proto::DUPENTRY" << std::endl;
            send_put_PlayerCharacter_result( sessionID, db_proto::DUPENTRY, data );
            return;
        } else {
            assertPrint( &mysql, query );
            return;
        }
    } else {
        std::cerr << "query success" << std::endl;
    }
    std::cerr << "db_proto::SUCCESS" << std::endl;    
    send_put_PlayerCharacter_result( sessionID, db_proto::SUCCESS, data );
}
void DBServer::recv_get_PlayerCharacter_by_id( vce::VUint32 sessionID, vce::VUint64 id )
{
    QueryMaker selqm( "SELECT "
                      "id"
                      ", "
                      "playerID"
                      ", "
                      "name"
                      ", "
                      "level"
                      ", "
                      "exp"
                      ", "
                      "hp"
                      ", "
                      "maxhp"
                      ", "
                      "floorID"
                      ", "
                      "x"
                      ", "
                      "y"
                      ", "
                      "equippedItemTypeID"
                      " "
                      " FROM PlayerCharacter WHERE ", "",""  );
    selqm.add_qword( "id", id );
    selqm.finish();
    std::cerr << "selquery:" << selqm.output() << std::endl;
    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 11 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::PlayerCharacter data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. id:" << id << std::endl;
            db_proto::PlayerCharacter data;            
            send_get_PlayerCharacter_by_id_result( sessionID, db_proto::NONE, ( PlayerCharacter*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].playerID = (vce::VUint64)atoll(row[cnt++]);
        strncpy( data[i].name, row[cnt++], 50 );
        data[i].name[50-1]='\0';
        data[i].level = (vce::VUint16)atoi(row[cnt++]);
        data[i].exp = (vce::VUint32)atoi(row[cnt++]);
        data[i].hp = (vce::VUint32)atoi(row[cnt++]);
        data[i].maxhp = (vce::VUint32)atoi(row[cnt++]);
        data[i].floorID = (vce::VUint32)atoi(row[cnt++]);
        data[i].x = (vce::VUint32)atoi(row[cnt++]);
        data[i].y = (vce::VUint32)atoi(row[cnt++]);
        data[i].equippedItemTypeID = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_PlayerCharacter_by_id_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// ranking func
void DBServer::recv_get_PlayerCharacter_ranking_by_id( vce::VUint32 sessionID, SortType sorttype, vce::VUint32 limit, vce::VUint32 offset )
{
    std::ostringstream ss;
    ss << "SELECT ";
    ss << "id";
    ss << ", ";
    ss << "playerID";
    ss << ", ";
    ss << "name";
    ss << ", ";
    ss << "level";
    ss << ", ";
    ss << "exp";
    ss << ", ";
    ss << "hp";
    ss << ", ";
    ss << "maxhp";
    ss << ", ";
    ss << "floorID";
    ss << ", ";
    ss << "x";
    ss << ", ";
    ss << "y";
    ss << ", ";
    ss << "equippedItemTypeID";
    ss << " ";
    ss << " FROM PlayerCharacter order by id ";
    if( sorttype == SORT_BIGGERFIRST ){
        ss << "desc ";
    }
    ss << "limit " << limit << " offset " << offset << ";";
    std::cerr << "query:" << ss.str() << std::endl;
    if( mysql_query( &mysql, ss.str().c_str())){
        assertPrint( &mysql, ss.str());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, ss.str());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 11 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::PlayerCharacter data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. " << std::endl;
            db_proto::PlayerCharacter data;
            send_get_PlayerCharacter_ranking_by_id_result( sessionID, db_proto::NONE, ( PlayerCharacter*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].playerID = (vce::VUint64)atoll(row[cnt++]);
        strncpy( data[i].name, row[cnt++], 50 );
        data[i].name[50-1]='\0';
        data[i].level = (vce::VUint16)atoi(row[cnt++]);
        data[i].exp = (vce::VUint32)atoi(row[cnt++]);
        data[i].hp = (vce::VUint32)atoi(row[cnt++]);
        data[i].maxhp = (vce::VUint32)atoi(row[cnt++]);
        data[i].floorID = (vce::VUint32)atoi(row[cnt++]);
        data[i].x = (vce::VUint32)atoi(row[cnt++]);
        data[i].y = (vce::VUint32)atoi(row[cnt++]);
        data[i].equippedItemTypeID = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_PlayerCharacter_ranking_by_id_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
void DBServer::recv_get_PlayerCharacter_by_playerID( vce::VUint32 sessionID, vce::VUint64 playerID )
{
    QueryMaker selqm( "SELECT "
                      "id"
                      ", "
                      "playerID"
                      ", "
                      "name"
                      ", "
                      "level"
                      ", "
                      "exp"
                      ", "
                      "hp"
                      ", "
                      "maxhp"
                      ", "
                      "floorID"
                      ", "
                      "x"
                      ", "
                      "y"
                      ", "
                      "equippedItemTypeID"
                      " "
                      " FROM PlayerCharacter WHERE ", "",""  );
    selqm.add_qword( "playerID", playerID );
    selqm.finish();
    std::cerr << "selquery:" << selqm.output() << std::endl;
    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 11 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::PlayerCharacter data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. playerID:" << playerID << std::endl;
            db_proto::PlayerCharacter data;            
            send_get_PlayerCharacter_by_playerID_result( sessionID, db_proto::NONE, ( PlayerCharacter*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].playerID = (vce::VUint64)atoll(row[cnt++]);
        strncpy( data[i].name, row[cnt++], 50 );
        data[i].name[50-1]='\0';
        data[i].level = (vce::VUint16)atoi(row[cnt++]);
        data[i].exp = (vce::VUint32)atoi(row[cnt++]);
        data[i].hp = (vce::VUint32)atoi(row[cnt++]);
        data[i].maxhp = (vce::VUint32)atoi(row[cnt++]);
        data[i].floorID = (vce::VUint32)atoi(row[cnt++]);
        data[i].x = (vce::VUint32)atoi(row[cnt++]);
        data[i].y = (vce::VUint32)atoi(row[cnt++]);
        data[i].equippedItemTypeID = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_PlayerCharacter_by_playerID_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// ranking func
void DBServer::recv_get_PlayerCharacter_ranking_by_playerID( vce::VUint32 sessionID, SortType sorttype, vce::VUint32 limit, vce::VUint32 offset )
{
    std::ostringstream ss;
    ss << "SELECT ";
    ss << "id";
    ss << ", ";
    ss << "playerID";
    ss << ", ";
    ss << "name";
    ss << ", ";
    ss << "level";
    ss << ", ";
    ss << "exp";
    ss << ", ";
    ss << "hp";
    ss << ", ";
    ss << "maxhp";
    ss << ", ";
    ss << "floorID";
    ss << ", ";
    ss << "x";
    ss << ", ";
    ss << "y";
    ss << ", ";
    ss << "equippedItemTypeID";
    ss << " ";
    ss << " FROM PlayerCharacter order by playerID ";
    if( sorttype == SORT_BIGGERFIRST ){
        ss << "desc ";
    }
    ss << "limit " << limit << " offset " << offset << ";";
    std::cerr << "query:" << ss.str() << std::endl;
    if( mysql_query( &mysql, ss.str().c_str())){
        assertPrint( &mysql, ss.str());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, ss.str());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 11 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::PlayerCharacter data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. " << std::endl;
            db_proto::PlayerCharacter data;
            send_get_PlayerCharacter_ranking_by_playerID_result( sessionID, db_proto::NONE, ( PlayerCharacter*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].playerID = (vce::VUint64)atoll(row[cnt++]);
        strncpy( data[i].name, row[cnt++], 50 );
        data[i].name[50-1]='\0';
        data[i].level = (vce::VUint16)atoi(row[cnt++]);
        data[i].exp = (vce::VUint32)atoi(row[cnt++]);
        data[i].hp = (vce::VUint32)atoi(row[cnt++]);
        data[i].maxhp = (vce::VUint32)atoi(row[cnt++]);
        data[i].floorID = (vce::VUint32)atoi(row[cnt++]);
        data[i].x = (vce::VUint32)atoi(row[cnt++]);
        data[i].y = (vce::VUint32)atoi(row[cnt++]);
        data[i].equippedItemTypeID = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_PlayerCharacter_ranking_by_playerID_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
void DBServer::recv_get_PlayerCharacter_by_name( vce::VUint32 sessionID, const char * name )
{
    QueryMaker selqm( "SELECT "
                      "id"
                      ", "
                      "playerID"
                      ", "
                      "name"
                      ", "
                      "level"
                      ", "
                      "exp"
                      ", "
                      "hp"
                      ", "
                      "maxhp"
                      ", "
                      "floorID"
                      ", "
                      "x"
                      ", "
                      "y"
                      ", "
                      "equippedItemTypeID"
                      " "
                      " FROM PlayerCharacter WHERE ", "",""  );
    selqm.add_string( "name", name );
    selqm.finish();
    std::cerr << "selquery:" << selqm.output() << std::endl;
    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 11 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::PlayerCharacter data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. name:" << name << std::endl;
            db_proto::PlayerCharacter data;            
            send_get_PlayerCharacter_by_name_result( sessionID, db_proto::NONE, ( PlayerCharacter*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].playerID = (vce::VUint64)atoll(row[cnt++]);
        strncpy( data[i].name, row[cnt++], 50 );
        data[i].name[50-1]='\0';
        data[i].level = (vce::VUint16)atoi(row[cnt++]);
        data[i].exp = (vce::VUint32)atoi(row[cnt++]);
        data[i].hp = (vce::VUint32)atoi(row[cnt++]);
        data[i].maxhp = (vce::VUint32)atoi(row[cnt++]);
        data[i].floorID = (vce::VUint32)atoi(row[cnt++]);
        data[i].x = (vce::VUint32)atoi(row[cnt++]);
        data[i].y = (vce::VUint32)atoi(row[cnt++]);
        data[i].equippedItemTypeID = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_PlayerCharacter_by_name_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// ranking func
void DBServer::recv_get_PlayerCharacter_ranking_by_name( vce::VUint32 sessionID, SortType sorttype, vce::VUint32 limit, vce::VUint32 offset )
{
    std::ostringstream ss;
    ss << "SELECT ";
    ss << "id";
    ss << ", ";
    ss << "playerID";
    ss << ", ";
    ss << "name";
    ss << ", ";
    ss << "level";
    ss << ", ";
    ss << "exp";
    ss << ", ";
    ss << "hp";
    ss << ", ";
    ss << "maxhp";
    ss << ", ";
    ss << "floorID";
    ss << ", ";
    ss << "x";
    ss << ", ";
    ss << "y";
    ss << ", ";
    ss << "equippedItemTypeID";
    ss << " ";
    ss << " FROM PlayerCharacter order by name ";
    if( sorttype == SORT_BIGGERFIRST ){
        ss << "desc ";
    }
    ss << "limit " << limit << " offset " << offset << ";";
    std::cerr << "query:" << ss.str() << std::endl;
    if( mysql_query( &mysql, ss.str().c_str())){
        assertPrint( &mysql, ss.str());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, ss.str());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 11 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::PlayerCharacter data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. " << std::endl;
            db_proto::PlayerCharacter data;
            send_get_PlayerCharacter_ranking_by_name_result( sessionID, db_proto::NONE, ( PlayerCharacter*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].playerID = (vce::VUint64)atoll(row[cnt++]);
        strncpy( data[i].name, row[cnt++], 50 );
        data[i].name[50-1]='\0';
        data[i].level = (vce::VUint16)atoi(row[cnt++]);
        data[i].exp = (vce::VUint32)atoi(row[cnt++]);
        data[i].hp = (vce::VUint32)atoi(row[cnt++]);
        data[i].maxhp = (vce::VUint32)atoi(row[cnt++]);
        data[i].floorID = (vce::VUint32)atoi(row[cnt++]);
        data[i].x = (vce::VUint32)atoi(row[cnt++]);
        data[i].y = (vce::VUint32)atoi(row[cnt++]);
        data[i].equippedItemTypeID = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_PlayerCharacter_ranking_by_name_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
void DBServer::recv_get_PlayerCharacter_by_level( vce::VUint32 sessionID, vce::VUint16 level )
{
    QueryMaker selqm( "SELECT "
                      "id"
                      ", "
                      "playerID"
                      ", "
                      "name"
                      ", "
                      "level"
                      ", "
                      "exp"
                      ", "
                      "hp"
                      ", "
                      "maxhp"
                      ", "
                      "floorID"
                      ", "
                      "x"
                      ", "
                      "y"
                      ", "
                      "equippedItemTypeID"
                      " "
                      " FROM PlayerCharacter WHERE ", "",""  );
    selqm.add_word( "level", level );
    selqm.finish();
    std::cerr << "selquery:" << selqm.output() << std::endl;
    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 11 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::PlayerCharacter data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. level:" << level << std::endl;
            db_proto::PlayerCharacter data;            
            send_get_PlayerCharacter_by_level_result( sessionID, db_proto::NONE, ( PlayerCharacter*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].playerID = (vce::VUint64)atoll(row[cnt++]);
        strncpy( data[i].name, row[cnt++], 50 );
        data[i].name[50-1]='\0';
        data[i].level = (vce::VUint16)atoi(row[cnt++]);
        data[i].exp = (vce::VUint32)atoi(row[cnt++]);
        data[i].hp = (vce::VUint32)atoi(row[cnt++]);
        data[i].maxhp = (vce::VUint32)atoi(row[cnt++]);
        data[i].floorID = (vce::VUint32)atoi(row[cnt++]);
        data[i].x = (vce::VUint32)atoi(row[cnt++]);
        data[i].y = (vce::VUint32)atoi(row[cnt++]);
        data[i].equippedItemTypeID = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_PlayerCharacter_by_level_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// ranking func
void DBServer::recv_get_PlayerCharacter_ranking_by_level( vce::VUint32 sessionID, SortType sorttype, vce::VUint32 limit, vce::VUint32 offset )
{
    std::ostringstream ss;
    ss << "SELECT ";
    ss << "id";
    ss << ", ";
    ss << "playerID";
    ss << ", ";
    ss << "name";
    ss << ", ";
    ss << "level";
    ss << ", ";
    ss << "exp";
    ss << ", ";
    ss << "hp";
    ss << ", ";
    ss << "maxhp";
    ss << ", ";
    ss << "floorID";
    ss << ", ";
    ss << "x";
    ss << ", ";
    ss << "y";
    ss << ", ";
    ss << "equippedItemTypeID";
    ss << " ";
    ss << " FROM PlayerCharacter order by level ";
    if( sorttype == SORT_BIGGERFIRST ){
        ss << "desc ";
    }
    ss << "limit " << limit << " offset " << offset << ";";
    std::cerr << "query:" << ss.str() << std::endl;
    if( mysql_query( &mysql, ss.str().c_str())){
        assertPrint( &mysql, ss.str());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, ss.str());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 11 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::PlayerCharacter data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. " << std::endl;
            db_proto::PlayerCharacter data;
            send_get_PlayerCharacter_ranking_by_level_result( sessionID, db_proto::NONE, ( PlayerCharacter*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].playerID = (vce::VUint64)atoll(row[cnt++]);
        strncpy( data[i].name, row[cnt++], 50 );
        data[i].name[50-1]='\0';
        data[i].level = (vce::VUint16)atoi(row[cnt++]);
        data[i].exp = (vce::VUint32)atoi(row[cnt++]);
        data[i].hp = (vce::VUint32)atoi(row[cnt++]);
        data[i].maxhp = (vce::VUint32)atoi(row[cnt++]);
        data[i].floorID = (vce::VUint32)atoi(row[cnt++]);
        data[i].x = (vce::VUint32)atoi(row[cnt++]);
        data[i].y = (vce::VUint32)atoi(row[cnt++]);
        data[i].equippedItemTypeID = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_PlayerCharacter_ranking_by_level_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// まずselectし、新規ならinsertし、既存ならupdateする。
void DBServer::recv_put_CharacterItem( vce::VUint32 sessionID, CharacterItem data )
{
    QueryMaker selqm( "SELECT id FROM CharacterItem WHERE ", "","" );    
    selqm.add_qword("id", data.id);
    selqm.finish();
    std::string selquery = selqm.output();
    std::cerr << "selquery: " << selquery << std::endl;
    if( mysql_query( &mysql, selquery.c_str())){
        assertPrint( &mysql, selquery );
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selquery);
        return;        
    }
    std::string query, queryBase;
    bool existing;
    if( mysql_num_rows(result) == 1 ){
        queryBase = std::string( "UPDATE" );
        existing = true;
    } else {
        queryBase = std::string( "INSERT INTO" );
        existing = false;
    }
    mysql_free_result(result);
    QueryMaker qm( queryBase.c_str(), "CharacterItem", "SET" ); 
    qm.add_qword("id", data.id);
    qm.add_qword("characterID", data.characterID);
    qm.add_dword("typeID", data.typeID);
    qm.add_dword("num", data.num);
    if( existing ){
        qm.append( " where " );
        qm.set_first();
        qm.add_qword( "id", data.id );
    }
    qm.finish();
    query = qm.output();
    std::cerr << "query: " << query << std::endl;
    if( mysql_query( &mysql, query.c_str())){
        if( mysql_errno(&mysql) == ER_DUP_ENTRY ){
            std::cerr << "db_proto::DUPENTRY" << std::endl;
            send_put_CharacterItem_result( sessionID, db_proto::DUPENTRY, data );
            return;
        } else {
            assertPrint( &mysql, query );
            return;
        }
    } else {
        std::cerr << "query success" << std::endl;
    }
    std::cerr << "db_proto::SUCCESS" << std::endl;    
    send_put_CharacterItem_result( sessionID, db_proto::SUCCESS, data );
}
void DBServer::recv_get_CharacterItem_by_id( vce::VUint32 sessionID, vce::VUint64 id )
{
    QueryMaker selqm( "SELECT "
                      "id"
                      ", "
                      "characterID"
                      ", "
                      "typeID"
                      ", "
                      "num"
                      " "
                      " FROM CharacterItem WHERE ", "",""  );
    selqm.add_qword( "id", id );
    selqm.finish();
    std::cerr << "selquery:" << selqm.output() << std::endl;
    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 4 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::CharacterItem data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. id:" << id << std::endl;
            db_proto::CharacterItem data;            
            send_get_CharacterItem_by_id_result( sessionID, db_proto::NONE, ( CharacterItem*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].characterID = (vce::VUint64)atoll(row[cnt++]);
        data[i].typeID = (vce::VUint32)atoi(row[cnt++]);
        data[i].num = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_CharacterItem_by_id_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// ranking func
void DBServer::recv_get_CharacterItem_ranking_by_id( vce::VUint32 sessionID, SortType sorttype, vce::VUint32 limit, vce::VUint32 offset )
{
    std::ostringstream ss;
    ss << "SELECT ";
    ss << "id";
    ss << ", ";
    ss << "characterID";
    ss << ", ";
    ss << "typeID";
    ss << ", ";
    ss << "num";
    ss << " ";
    ss << " FROM CharacterItem order by id ";
    if( sorttype == SORT_BIGGERFIRST ){
        ss << "desc ";
    }
    ss << "limit " << limit << " offset " << offset << ";";
    std::cerr << "query:" << ss.str() << std::endl;
    if( mysql_query( &mysql, ss.str().c_str())){
        assertPrint( &mysql, ss.str());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, ss.str());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 4 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::CharacterItem data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. " << std::endl;
            db_proto::CharacterItem data;
            send_get_CharacterItem_ranking_by_id_result( sessionID, db_proto::NONE, ( CharacterItem*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].characterID = (vce::VUint64)atoll(row[cnt++]);
        data[i].typeID = (vce::VUint32)atoi(row[cnt++]);
        data[i].num = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_CharacterItem_ranking_by_id_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
void DBServer::recv_get_CharacterItem_by_characterID( vce::VUint32 sessionID, vce::VUint64 characterID )
{
    QueryMaker selqm( "SELECT "
                      "id"
                      ", "
                      "characterID"
                      ", "
                      "typeID"
                      ", "
                      "num"
                      " "
                      " FROM CharacterItem WHERE ", "",""  );
    selqm.add_qword( "characterID", characterID );
    selqm.finish();
    std::cerr << "selquery:" << selqm.output() << std::endl;
    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 4 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::CharacterItem data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. characterID:" << characterID << std::endl;
            db_proto::CharacterItem data;            
            send_get_CharacterItem_by_characterID_result( sessionID, db_proto::NONE, ( CharacterItem*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].characterID = (vce::VUint64)atoll(row[cnt++]);
        data[i].typeID = (vce::VUint32)atoi(row[cnt++]);
        data[i].num = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_CharacterItem_by_characterID_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// ranking func
void DBServer::recv_get_CharacterItem_ranking_by_characterID( vce::VUint32 sessionID, SortType sorttype, vce::VUint32 limit, vce::VUint32 offset )
{
    std::ostringstream ss;
    ss << "SELECT ";
    ss << "id";
    ss << ", ";
    ss << "characterID";
    ss << ", ";
    ss << "typeID";
    ss << ", ";
    ss << "num";
    ss << " ";
    ss << " FROM CharacterItem order by characterID ";
    if( sorttype == SORT_BIGGERFIRST ){
        ss << "desc ";
    }
    ss << "limit " << limit << " offset " << offset << ";";
    std::cerr << "query:" << ss.str() << std::endl;
    if( mysql_query( &mysql, ss.str().c_str())){
        assertPrint( &mysql, ss.str());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, ss.str());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 4 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::CharacterItem data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. " << std::endl;
            db_proto::CharacterItem data;
            send_get_CharacterItem_ranking_by_characterID_result( sessionID, db_proto::NONE, ( CharacterItem*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].characterID = (vce::VUint64)atoll(row[cnt++]);
        data[i].typeID = (vce::VUint32)atoi(row[cnt++]);
        data[i].num = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_CharacterItem_ranking_by_characterID_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// まずselectし、新規ならinsertし、既存ならupdateする。
void DBServer::recv_put_CharacterSkill( vce::VUint32 sessionID, CharacterSkill data )
{
    QueryMaker selqm( "SELECT id FROM CharacterSkill WHERE ", "","" );    
    selqm.add_qword("id", data.id);
    selqm.finish();
    std::string selquery = selqm.output();
    std::cerr << "selquery: " << selquery << std::endl;
    if( mysql_query( &mysql, selquery.c_str())){
        assertPrint( &mysql, selquery );
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selquery);
        return;        
    }
    std::string query, queryBase;
    bool existing;
    if( mysql_num_rows(result) == 1 ){
        queryBase = std::string( "UPDATE" );
        existing = true;
    } else {
        queryBase = std::string( "INSERT INTO" );
        existing = false;
    }
    mysql_free_result(result);
    QueryMaker qm( queryBase.c_str(), "CharacterSkill", "SET" ); 
    qm.add_qword("id", data.id);
    qm.add_qword("characterID", data.characterID);
    qm.add_dword("typeID", data.typeID);
    qm.add_dword("level", data.level);
    if( existing ){
        qm.append( " where " );
        qm.set_first();
        qm.add_qword( "id", data.id );
    }
    qm.finish();
    query = qm.output();
    std::cerr << "query: " << query << std::endl;
    if( mysql_query( &mysql, query.c_str())){
        if( mysql_errno(&mysql) == ER_DUP_ENTRY ){
            std::cerr << "db_proto::DUPENTRY" << std::endl;
            send_put_CharacterSkill_result( sessionID, db_proto::DUPENTRY, data );
            return;
        } else {
            assertPrint( &mysql, query );
            return;
        }
    } else {
        std::cerr << "query success" << std::endl;
    }
    std::cerr << "db_proto::SUCCESS" << std::endl;    
    send_put_CharacterSkill_result( sessionID, db_proto::SUCCESS, data );
}
void DBServer::recv_get_CharacterSkill_by_id( vce::VUint32 sessionID, vce::VUint64 id )
{
    QueryMaker selqm( "SELECT "
                      "id"
                      ", "
                      "characterID"
                      ", "
                      "typeID"
                      ", "
                      "level"
                      " "
                      " FROM CharacterSkill WHERE ", "",""  );
    selqm.add_qword( "id", id );
    selqm.finish();
    std::cerr << "selquery:" << selqm.output() << std::endl;
    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 4 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::CharacterSkill data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. id:" << id << std::endl;
            db_proto::CharacterSkill data;            
            send_get_CharacterSkill_by_id_result( sessionID, db_proto::NONE, ( CharacterSkill*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].characterID = (vce::VUint64)atoll(row[cnt++]);
        data[i].typeID = (vce::VUint32)atoi(row[cnt++]);
        data[i].level = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_CharacterSkill_by_id_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// ranking func
void DBServer::recv_get_CharacterSkill_ranking_by_id( vce::VUint32 sessionID, SortType sorttype, vce::VUint32 limit, vce::VUint32 offset )
{
    std::ostringstream ss;
    ss << "SELECT ";
    ss << "id";
    ss << ", ";
    ss << "characterID";
    ss << ", ";
    ss << "typeID";
    ss << ", ";
    ss << "level";
    ss << " ";
    ss << " FROM CharacterSkill order by id ";
    if( sorttype == SORT_BIGGERFIRST ){
        ss << "desc ";
    }
    ss << "limit " << limit << " offset " << offset << ";";
    std::cerr << "query:" << ss.str() << std::endl;
    if( mysql_query( &mysql, ss.str().c_str())){
        assertPrint( &mysql, ss.str());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, ss.str());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 4 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::CharacterSkill data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. " << std::endl;
            db_proto::CharacterSkill data;
            send_get_CharacterSkill_ranking_by_id_result( sessionID, db_proto::NONE, ( CharacterSkill*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].characterID = (vce::VUint64)atoll(row[cnt++]);
        data[i].typeID = (vce::VUint32)atoi(row[cnt++]);
        data[i].level = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_CharacterSkill_ranking_by_id_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
void DBServer::recv_get_CharacterSkill_by_characterID( vce::VUint32 sessionID, vce::VUint64 characterID )
{
    QueryMaker selqm( "SELECT "
                      "id"
                      ", "
                      "characterID"
                      ", "
                      "typeID"
                      ", "
                      "level"
                      " "
                      " FROM CharacterSkill WHERE ", "",""  );
    selqm.add_qword( "characterID", characterID );
    selqm.finish();
    std::cerr << "selquery:" << selqm.output() << std::endl;
    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 4 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::CharacterSkill data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. characterID:" << characterID << std::endl;
            db_proto::CharacterSkill data;            
            send_get_CharacterSkill_by_characterID_result( sessionID, db_proto::NONE, ( CharacterSkill*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].characterID = (vce::VUint64)atoll(row[cnt++]);
        data[i].typeID = (vce::VUint32)atoi(row[cnt++]);
        data[i].level = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_CharacterSkill_by_characterID_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// ranking func
void DBServer::recv_get_CharacterSkill_ranking_by_characterID( vce::VUint32 sessionID, SortType sorttype, vce::VUint32 limit, vce::VUint32 offset )
{
    std::ostringstream ss;
    ss << "SELECT ";
    ss << "id";
    ss << ", ";
    ss << "characterID";
    ss << ", ";
    ss << "typeID";
    ss << ", ";
    ss << "level";
    ss << " ";
    ss << " FROM CharacterSkill order by characterID ";
    if( sorttype == SORT_BIGGERFIRST ){
        ss << "desc ";
    }
    ss << "limit " << limit << " offset " << offset << ";";
    std::cerr << "query:" << ss.str() << std::endl;
    if( mysql_query( &mysql, ss.str().c_str())){
        assertPrint( &mysql, ss.str());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, ss.str());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 4 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::CharacterSkill data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. " << std::endl;
            db_proto::CharacterSkill data;
            send_get_CharacterSkill_ranking_by_characterID_result( sessionID, db_proto::NONE, ( CharacterSkill*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].id = (vce::VUint64)atoll(row[cnt++]);
        data[i].characterID = (vce::VUint64)atoll(row[cnt++]);
        data[i].typeID = (vce::VUint32)atoi(row[cnt++]);
        data[i].level = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_CharacterSkill_ranking_by_characterID_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// まずselectし、新規ならinsertし、既存ならupdateする。
void DBServer::recv_put_PlayerLock( vce::VUint32 sessionID, PlayerLock data )
{
    QueryMaker selqm( "SELECT playerID FROM PlayerLock WHERE ", "","" );    
    selqm.add_qword("playerID", data.playerID);
    selqm.finish();
    std::string selquery = selqm.output();
    std::cerr << "selquery: " << selquery << std::endl;
    if( mysql_query( &mysql, selquery.c_str())){
        assertPrint( &mysql, selquery );
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selquery);
        return;        
    }
    std::string query, queryBase;
    bool existing;
    if( mysql_num_rows(result) == 1 ){
        queryBase = std::string( "UPDATE" );
        existing = true;
    } else {
        queryBase = std::string( "INSERT INTO" );
        existing = false;
    }
    mysql_free_result(result);
    QueryMaker qm( queryBase.c_str(), "PlayerLock", "SET" ); 
    qm.add_qword("playerID", data.playerID);
    qm.add_byte("state", data.state);
    qm.add_dword("ownerServerID", data.ownerServerID);
    if( existing ){
        qm.append( " where " );
        qm.set_first();
        qm.add_qword( "playerID", data.playerID );
    }
    qm.finish();
    query = qm.output();
    std::cerr << "query: " << query << std::endl;
    if( mysql_query( &mysql, query.c_str())){
        if( mysql_errno(&mysql) == ER_DUP_ENTRY ){
            std::cerr << "db_proto::DUPENTRY" << std::endl;
            send_put_PlayerLock_result( sessionID, db_proto::DUPENTRY, data );
            return;
        } else {
            assertPrint( &mysql, query );
            return;
        }
    } else {
        std::cerr << "query success" << std::endl;
    }
    std::cerr << "db_proto::SUCCESS" << std::endl;    
    send_put_PlayerLock_result( sessionID, db_proto::SUCCESS, data );
}
void DBServer::recv_get_PlayerLock_by_playerID( vce::VUint32 sessionID, vce::VUint64 playerID )
{
    QueryMaker selqm( "SELECT "
                      "playerID"
                      ", "
                      "state"
                      ", "
                      "ownerServerID"
                      " "
                      " FROM PlayerLock WHERE ", "",""  );
    selqm.add_qword( "playerID", playerID );
    selqm.finish();
    std::cerr << "selquery:" << selqm.output() << std::endl;
    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 3 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::PlayerLock data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. playerID:" << playerID << std::endl;
            db_proto::PlayerLock data;            
            send_get_PlayerLock_by_playerID_result( sessionID, db_proto::NONE, ( PlayerLock*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].playerID = (vce::VUint64)atoll(row[cnt++]);
        data[i].state = (vce::VUint8)atoi(row[cnt++]);
        data[i].ownerServerID = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_PlayerLock_by_playerID_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// ranking func
void DBServer::recv_get_PlayerLock_ranking_by_playerID( vce::VUint32 sessionID, SortType sorttype, vce::VUint32 limit, vce::VUint32 offset )
{
    std::ostringstream ss;
    ss << "SELECT ";
    ss << "playerID";
    ss << ", ";
    ss << "state";
    ss << ", ";
    ss << "ownerServerID";
    ss << " ";
    ss << " FROM PlayerLock order by playerID ";
    if( sorttype == SORT_BIGGERFIRST ){
        ss << "desc ";
    }
    ss << "limit " << limit << " offset " << offset << ";";
    std::cerr << "query:" << ss.str() << std::endl;
    if( mysql_query( &mysql, ss.str().c_str())){
        assertPrint( &mysql, ss.str());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, ss.str());
        return;
    }
    int numFields;
    MYSQL_FIELD *fields;
    numFields = mysql_num_fields(result);
    if( numFields != 3 ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::PlayerLock data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. " << std::endl;
            db_proto::PlayerLock data;
            send_get_PlayerLock_ranking_by_playerID_result( sessionID, db_proto::NONE, ( PlayerLock*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }
        int cnt=0;
        data[i].playerID = (vce::VUint64)atoll(row[cnt++]);
        data[i].state = (vce::VUint8)atoi(row[cnt++]);
        data[i].ownerServerID = (vce::VUint32)atoi(row[cnt++]);
        actualRows = i+1;
    }
    send_get_PlayerLock_ranking_by_playerID_result( sessionID, db_proto::SUCCESS, data, actualRows );
    mysql_free_result(result);            
}
// LockSVをDBMSを使って実装するための関数。
// テーブルを指定したフィールドの値が指定した値に等しいときだけ、指定した値でupdateする。
// updateをかけた後の値をselectして返す。
void DBServer::recv_put_PlayerLock_if_state( vce::VUint32 sessionID, PlayerLock data, vce::VUint8 state_test )
{
    std::string lockq( "LOCK TABLES PlayerLock WRITE" );
    if( mysql_query( &mysql, lockq.c_str() )){
        assertPrint( &mysql, lockq );
        return;
    }
    QueryMaker qm( "UPDATE", "PlayerLock", "SET" );
    qm.add_qword("playerID", data.playerID );
    qm.add_byte("state", data.state );
    qm.add_dword("ownerServerID", data.ownerServerID );
    qm.append( " WHERE " );
    qm.set_first();
    qm.add_qword( "playerID", data.playerID );
    qm.append( " AND " );
    qm.set_first();
    qm.add_qword( "state", state_test );
    qm.finish();
    std::string query = qm.output();
    std::cerr << "query: " << query << std::endl;
    if( mysql_query( &mysql, query.c_str())){
        assertPrint( &mysql, query );
        return;
    }
    // updateした後のDBから読み出す必要がある。put関数ではselectをしていないがこっちではする。
    QueryMaker selqm( "SELECT "
                      "playerID"
                      ", "
                      "state"
                      ", "
                      "ownerServerID"
                      " "
                      " FROM PlayerLock WHERE ", "",""  );
    selqm.add_qword( "playerID", data.playerID );
    selqm.finish();
    std::cerr << "selquery:" << selqm.output() << std::endl;    
    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_ROW row;
    if( !(row = mysql_fetch_row(result))){
        std::cerr << "no row. state:" << data.state << std::endl;
        send_put_PlayerLock_if_state_result( sessionID, db_proto::FAIL, data );
        mysql_free_result(result);
        if( mysql_query( &mysql, "UNLOCK TABLES" ) ){
            assertPrint( &mysql, "UNLOCK TABLES" );
            return;
        }
        return;
    }
    if( mysql_query( &mysql, "UNLOCK TABLES" ) ){
        assertPrint( &mysql, "UNLOCK TABLES" );
        return;
    }
    db_proto::PlayerLock selectdata;
    int cnt=0;
    std::cerr << "ROW:" << row[cnt] << std::endl;
    selectdata.playerID = (vce::VUint64)atoll(row[cnt++]);
    std::cerr << "ROW:" << row[cnt] << std::endl;
    selectdata.state = (vce::VUint8)atoi(row[cnt++]);
    std::cerr << "ROW:" << row[cnt] << std::endl;
    selectdata.ownerServerID = (vce::VUint32)atoi(row[cnt++]);
    send_put_PlayerLock_if_state_result( sessionID, db_proto::SUCCESS, selectdata );
}
int main( int argc, char **argv )
{
    // VCEミドルウェアを初期化する
    vce::VCEInitialize();
    vce::VCE *vceobj = vce::VCECreateInstance();
    vceobj->SetPollingWait(true);
    vceobj->ReUseAddress(true);
    vceobj->SetSelectAlgorithmCallback(MySelectAlgorithmCallback);
    // mysqlへの接続を1本だけ初期化し、すべてのセッションで共有する
    printf("dbsv: MySQL cli version: %s\n", mysql_get_client_info());
    mysql_init(&mysql);
    if( !mysql_real_connect(&mysql, "127.0.0.1", "storage", "", "k", 0, NULL, 0 )){
        std::cerr << "mysql_real_connect error: " << mysql_error(&mysql) << std::endl;
        return 1;
    } else {
        std::cerr << "mysql_real_connect ok" << std::endl;
    }
    // LogサーバのTCPリスナを初期化する
    vceobj->Listen(new vce::AutoAccepter<DBServer>, 10010);
    std::cerr << "dbsv start" << std::endl;    
    while(true){
        vceobj->Poll();
    }
    return 0;
}
