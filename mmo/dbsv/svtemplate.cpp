/*
  dbsv : generated by dbgen.py, do not edit this!!
 */
// 通信ミドルウェアのヘッダ
#include "vce2.h"

// logサーバが実装する通信プロトコルを定義するためのヘッダ
#include "dbproto.h" 

// 標準ライブラリを使うためのヘッダ
#include <iostream>

// MySQLアクセスのためのヘッダ

#include "my_global.h"
#include "mysql.h"
#include "mysqld_error.h"

// プロジェクトで作成したヘッダ
#include "dbsvmain.h"
#include "qm.h"
#include "util.h"

// dbsvではたった1個のmysqlへのセッションを共有する
MYSQL mysql;

size_t DBServer::Recv(const vce::VUint8 *p,size_t sz){
    std::cerr << "recv:" << sz << std::endl;        
    return db_proto_server::Recv(p,sz);
};

void assertPrint( MYSQL*m, std::string q ){
    std::cerr << "mysql_query fail:" << mysql_error(m) << ":" << q << std::endl;
    assert(0);    
}

void DBServer::recv_ping( vce::VUint64 timestamp )
{
    send_ping(timestamp);
}

// 新しいIDを生成して確保する
void DBServer::recv_getNewID(vce::VUint32 num)
{
    vce::VUint64 ids[MAXIDSET];
    if( num > MAXIDSET ){
        num = MAXIDSET;
    }

    std::string upd_q( "UPDATE id_generator SET id=LAST_INSERT_ID(id+1);" );
    std::string sel_q( "SELECT LAST_INSERT_ID();" );
    
    for(int i=0;i<num;i++){
        if( mysql_query( &mysql, upd_q.c_str())){
            assertPrint( &mysql, upd_q );
            return;
        }
        if( mysql_query( &mysql, sel_q.c_str())){
            assertPrint( &mysql, sel_q );
            return;
        }
        MYSQL_RES *result;
        if( !(result = mysql_store_result(&mysql))){
            assertPrint( &mysql, sel_q );
            return;
        }
        MYSQL_ROW row;
        if( !(row=mysql_fetch_row(result))){
            mysql_free_result(result);
            assertPrint( &mysql, "no row!");
            return;
        }
        mysql_free_result(result);
        
        ids[i] = atoll( row[0] );
    }

    std::cerr << "recv_getNewID: sending new " << num << " ids" << std::endl;
    send_getNewIDResult( ids, num );
}







//{% for t in db.tables %}

// まずselectし、新規ならinsertし、既存ならupdateする。
void DBServer::recv_put_{{t.name}}( vce::VUint32 sessionID, {{t.struct_name}} data )
{

    //  {% for qf in t.fields %}
    //    {% if qf.primary %}
    QueryMaker selqm( "SELECT {{qf.name}} FROM {{t.name}} WHERE ", "","" );    
    selqm.add_{{qf.type}}("{{qf.name}}", data.{{qf.name}});
    selqm.finish();
    std::string selquery = selqm.output();
    std::cerr << "selquery: " << selquery << std::endl;
    //    {% endif %}
    //  {% endfor %}
    if( mysql_query( &mysql, selquery.c_str())){
        assertPrint( &mysql, selquery );
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selquery);
        return;        
    }
    
    std::string query, queryBase;
    bool existing;
    if( mysql_num_rows(result) == 1 ){
        queryBase = std::string( "UPDATE" );
        existing = true;
    } else {
        queryBase = std::string( "INSERT INTO" );
        existing = false;
    }
    mysql_free_result(result);

    QueryMaker qm( queryBase.c_str(), "{{t.name}}", "SET" ); 
    //  {% for qf in t.fields %}
    qm.add_{{qf.type}}("{{qf.name}}", data.{{qf.name}});
    //  {% endfor %}
    if( existing ){
        qm.append( " where " );
        qm.set_first();
        qm.add_{{t.get_primary.type}}( "{{t.get_primary.name}}", data.{{t.get_primary.name}} );
    }
    qm.finish();
    query = qm.output();
    std::cerr << "query: " << query << std::endl;

    if( mysql_query( &mysql, query.c_str())){
        if( mysql_errno(&mysql) == ER_DUP_ENTRY ){
            std::cerr << "db_proto::DUPENTRY" << std::endl;
            send_put_{{t.name}}_result( sessionID, db_proto::DUPENTRY, data );
            return;
        } else {
            assertPrint( &mysql, query );
            return;
        }
    } else {
        std::cerr << "query success" << std::endl;
    }

    std::cerr << "db_proto::SUCCESS" << std::endl;    
    send_put_{{t.name}}_result( sessionID, db_proto::SUCCESS, data );
}


//  {% for f in t.fields %}
//    {% if f.index or f.primary %}
void DBServer::recv_get_{{t.name}}_by_{{f.name}}( vce::VUint32 sessionID, {{f.type_in_cpp}} {{f.name }} )
{

    QueryMaker selqm( "SELECT "
                      // {% for qf in t.fields %}
                      "{{qf.name}}"
                      //   {% if forloop.last %}
                      " "
                      //   {% else %}
                      ", "
                      //   {% endif %}
                      // {% endfor %} 
                      " FROM {{t.name}} WHERE ", "",""  );
    selqm.add_{{f.type}}( "{{f.name}}", {{f.name}} );
    selqm.finish();
        

    std::cerr << "selquery:" << selqm.output() << std::endl;
    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }

    int numFields;
    MYSQL_FIELD *fields;
    
    numFields = mysql_num_fields(result);
    if( numFields != {{ t.fields|length }} ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::{{ t.struct_name }} data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. {{f.name}}:" << {{f.name}} << std::endl;
            db_proto::{{ t.struct_name }} data;            
            send_get_{{t.name}}_by_{{f.name}}_result( sessionID, db_proto::NONE, ( {{t.struct_name}}*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }

        int cnt=0;
    // {% for qf in t.fields %}
    //   {% if qf.is_string %}
        strncpy( data[i].{{qf.name}}, row[cnt++], {{qf.size}} );
        data[i].{{qf.name}}[{{qf.size}}-1]='\0';
    //   {% else %}
        data[i].{{qf.name}} = ({{qf.type_in_cpp}}){{qf.converter}}(row[cnt++]);
    //   {% endif %}
    // {% endfor %}
        actualRows = i+1;
    }
    send_get_{{t.name}}_by_{{f.name}}_result( sessionID, db_proto::SUCCESS, data, actualRows );

    mysql_free_result(result);            
}

// ranking func
void DBServer::recv_get_{{t.name}}_ranking_by_{{f.name}}( vce::VUint32 sessionID, SortType sorttype, vce::VUint32 limit, vce::VUint32 offset )
{
    std::ostringstream ss;
    ss << "SELECT ";
    // {% for qf in t.fields %}
    ss << "{{qf.name}}";
    //   {% if forloop.last %}
    ss << " ";
    //   {% else %}
    ss << ", ";
    //   {% endif %}
    // {% endfor %} 
    ss << " FROM {{t.name}} order by {{f.name}} ";
    if( sorttype == SORT_BIGGERFIRST ){
        ss << "desc ";
    }
    ss << "limit " << limit << " offset " << offset << ";";

    std::cerr << "query:" << ss.str() << std::endl;
    if( mysql_query( &mysql, ss.str().c_str())){
        assertPrint( &mysql, ss.str());
        return;
    }
    
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, ss.str());
        return;
    }

    int numFields;
    MYSQL_FIELD *fields;
    
    numFields = mysql_num_fields(result);
    if( numFields != {{ t.fields|length }} ){
        std::cerr << "numFields differ.." << numFields << std::endl;
        assert(0);
        return;
    }
    int numRows = mysql_num_rows(result);
    std::cerr << "numRows:" << numRows << std::endl;
    const int maxRows = 100;
    db_proto::{{ t.struct_name }} data[maxRows];
    int actualRows=0;
    for( int i=0;i<numRows&&i<maxRows;i++){
        MYSQL_ROW row;
        // 1行だけ取る
        if( !(row = mysql_fetch_row(result)) ){
            std::cerr << "no row. " << std::endl;
            db_proto::{{ t.struct_name }} data;
            
            send_get_{{t.name}}_ranking_by_{{f.name}}_result( sessionID, db_proto::NONE, ( {{t.struct_name}}*) &data, (vce::VUint32)1  );
            mysql_free_result(result);        
            return;
        }

        int cnt=0;
    // {% for qf in t.fields %}
    //   {% if qf.is_string %}
        strncpy( data[i].{{qf.name}}, row[cnt++], {{qf.size}} );
        data[i].{{qf.name}}[{{qf.size}}-1]='\0';
    //   {% else %}
        data[i].{{qf.name}} = ({{qf.type_in_cpp}}){{qf.converter}}(row[cnt++]);
    //   {% endif %}
    // {% endfor %}
        actualRows = i+1;
    }
    send_get_{{t.name}}_ranking_by_{{f.name}}_result( sessionID, db_proto::SUCCESS, data, actualRows );

    mysql_free_result(result);            

}


//    {% endif %}
//    {% if f.conditional %}

// LockSVをDBMSを使って実装するための関数。
// テーブルを指定したフィールドの値が指定した値に等しいときだけ、指定した値でupdateする。
// updateをかけた後の値をselectして返す。
void DBServer::recv_put_{{t.name}}_if_{{f.name}}( vce::VUint32 sessionID, {{t.struct_name}} data, {{f.type_in_cpp}} {{f.name}}_test )
{
    std::string lockq( "LOCK TABLES {{t.name}} WRITE" );
    if( mysql_query( &mysql, lockq.c_str() )){
        assertPrint( &mysql, lockq );
        return;
    }
    QueryMaker qm( "UPDATE", "{{t.name}}", "SET" );
    // {% for qf in t.fields %}
    qm.add_{{qf.type}}("{{qf.name}}", data.{{qf.name}} );
    // {% endfor %}
    qm.append( " WHERE " );
    qm.set_first();
    qm.add_{{t.get_primary.type}}( "{{t.get_primary.name}}", data.{{t.get_primary.name}} );
    qm.append( " AND " );
    qm.set_first();
    qm.add_{{t.get_primary.type}}( "{{f.name}}", {{f.name}}_test );
    qm.finish();
    std::string query = qm.output();
    std::cerr << "query: " << query << std::endl;

    if( mysql_query( &mysql, query.c_str())){
        assertPrint( &mysql, query );
        return;
    }

    // updateした後のDBから読み出す必要がある。put関数ではselectをしていないがこっちではする。
    QueryMaker selqm( "SELECT "
                      // {% for qf in t.fields %}
                      "{{qf.name}}"
                      //   {% if forloop.last %}
                      " "
                      //   {% else %}
                      ", "
                      //   {% endif %}
                      // {% endfor %} 
                      " FROM {{t.name}} WHERE ", "",""  );
    selqm.add_{{t.get_primary.type}}( "{{t.get_primary.name}}", data.{{t.get_primary.name}} );
    selqm.finish();
    std::cerr << "selquery:" << selqm.output() << std::endl;    

    if( mysql_query( &mysql, selqm.output().c_str())){
        assertPrint( &mysql, selqm.output());
        return;
    }
    MYSQL_RES *result;
    if( !(result = mysql_store_result( &mysql ))){
        assertPrint( &mysql, selqm.output());
        return;
    }
    


    MYSQL_ROW row;
    if( !(row = mysql_fetch_row(result))){
        std::cerr << "no row. {{f.name}}:" << data.{{f.name}} << std::endl;
        send_put_{{t.name}}_if_{{f.name}}_result( sessionID, db_proto::FAIL, data );
        mysql_free_result(result);
        if( mysql_query( &mysql, "UNLOCK TABLES" ) ){
            assertPrint( &mysql, "UNLOCK TABLES" );
            return;
        }
        return;
    }

    if( mysql_query( &mysql, "UNLOCK TABLES" ) ){
        assertPrint( &mysql, "UNLOCK TABLES" );
        return;
    }

    db_proto::{{ t.struct_name}} selectdata;
    int cnt=0;
    // {% for qf in t.fields %}
    //   {% if qf.is_string %}
    strncpy( selectdata.{{qf.name}}, row[cnt++], {{qf.size}} );
    selectdata.{{qf.name}}[{{qf.size}}-1]='\0';
    //   {% else %}
    std::cerr << "ROW:" << row[cnt] << std::endl;
    selectdata.{{qf.name}} = ({{qf.type_in_cpp}}){{qf.converter}}(row[cnt++]);

    
    //   {% endif %}
    // {% endfor %}

    send_put_{{t.name}}_if_{{f.name}}_result( sessionID, db_proto::SUCCESS, selectdata );


}



//    {% endif %}
//  {% endfor %}
//{% endfor %}




int main( int argc, char **argv )
{
    // VCEミドルウェアを初期化する
    vce::VCEInitialize();
    vce::VCE *vceobj = vce::VCECreateInstance();
    vceobj->SetPollingWait(true);
    vceobj->ReUseAddress(true);
    vceobj->SetSelectAlgorithmCallback(MySelectAlgorithmCallback);
    
    // mysqlへの接続を1本だけ初期化し、すべてのセッションで共有する
    printf("dbsv: MySQL cli version: %s\n", mysql_get_client_info());
    
    mysql_init(&mysql);
    if( !mysql_real_connect(&mysql, "127.0.0.1", "storage", "", "{{db.name}}", 0, NULL, 0 )){
        std::cerr << "mysql_real_connect error: " << mysql_error(&mysql) << std::endl;
        return 1;
    } else {
        std::cerr << "mysql_real_connect ok" << std::endl;
    }

    // LogサーバのTCPリスナを初期化する
    vceobj->Listen(new vce::AutoAccepter<DBServer>, 10010);


    std::cerr << "dbsv start" << std::endl;    
    while(true){
        vceobj->Poll();
    }
    return 0;
    
}

